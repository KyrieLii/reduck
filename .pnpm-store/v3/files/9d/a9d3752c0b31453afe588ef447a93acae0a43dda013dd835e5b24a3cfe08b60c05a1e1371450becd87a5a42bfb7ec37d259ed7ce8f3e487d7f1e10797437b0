import type { Middleware } from 'farrow-pipeline';
import { ResponseInfo, string, json, html, text, redirect, stream, file, vary, cookie, cookies, header, headers, status, buffer, empty, attachment, custom, type, BodyMap } from './responseInfo';
declare type ResponseInfoCreator = (...args: any) => ResponseInfo;
declare type ToResponse<T extends ResponseInfoCreator> = (...args: Parameters<T>) => Response;
export declare type Response = {
    info: ResponseInfo;
    merge: (...responsers: Response[]) => Response;
    is: (...types: string[]) => string | false;
    string: ToResponse<typeof string>;
    json: ToResponse<typeof json>;
    html: ToResponse<typeof html>;
    text: ToResponse<typeof text>;
    redirect: ToResponse<typeof redirect>;
    stream: ToResponse<typeof stream>;
    file: ToResponse<typeof file>;
    vary: ToResponse<typeof vary>;
    cookie: ToResponse<typeof cookie>;
    cookies: ToResponse<typeof cookies>;
    header: ToResponse<typeof header>;
    headers: ToResponse<typeof headers>;
    status: ToResponse<typeof status>;
    buffer: ToResponse<typeof buffer>;
    empty: ToResponse<typeof empty>;
    attachment: ToResponse<typeof attachment>;
    custom: ToResponse<typeof custom>;
    type: ToResponse<typeof type>;
};
export declare const toResponse: <T extends ResponseInfoCreator>(f: T, info: ResponseInfo) => ToResponse<T>;
export declare const createResponse: (info: ResponseInfo) => Response;
export declare const Response: Response;
export declare type MaybeAsyncResponse = Response | Promise<Response>;
export declare const matchBodyType: <T extends "string" | "empty" | "json" | "stream" | "buffer" | "redirect" | "file" | "custom">(type: T, f: (body: BodyMap[T]) => MaybeAsyncResponse) => Middleware<any, MaybeAsyncResponse>;
export {};
