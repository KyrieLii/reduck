"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWillCompilerCode = exports.buildSourceCode = exports.Compiler = void 0;

var _utils = require("@modern-js/utils");

var _initEnv = require("../utils/init-env");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const babelCompiler = _utils.Import.lazy('@modern-js/babel-compiler', require);

const argv = _utils.Import.lazy('process.argv', require);

const core = _utils.Import.lazy('@modern-js/core', require);

const bc = _utils.Import.lazy('../utils/babel', require);

const ts = _utils.Import.lazy('../utils/tsconfig', require);

let Compiler;
exports.Compiler = Compiler;

(function (Compiler) {
  Compiler[Compiler["babel"] = 0] = "babel";
  Compiler[Compiler["esbuild"] = 1] = "esbuild";
  Compiler[Compiler["swc"] = 2] = "swc";
})(Compiler || (exports.Compiler = Compiler = {}));

const runBabelCompiler = async (willCompilerFiles, config, babelConfig = {}) => {
  const {
    srcRootDir,
    distDir
  } = config; // TODO: 判断lynx模式下，修改distFileExtMap: {'js': 'js', 'jsx': 'jsx', 'ts': 'js', 'tsx': 'jsx'}

  return babelCompiler.compiler({
    quiet: true,
    enableVirtualDist: true,
    rootDir: srcRootDir,
    filenames: willCompilerFiles,
    distDir,
    ignore: ['*.d.ts']
  }, babelConfig);
};

const getWillCompilerCode = (srcDirOrFile, option) => {
  const {
    tsconfig,
    isTsProject
  } = option; // 如果是一个文件路径，则直接返回

  if (_utils.fs.existsSync(srcDirOrFile) && _utils.fs.lstatSync(srcDirOrFile).isFile()) {
    return [srcDirOrFile];
  }

  const getExts = isTs => {
    // TODO: 是否受控tsconfig.json 里的jsx配置
    let exts = [];

    if (isTs) {
      var _tsconfig$compilerOpt;

      exts = tsconfig !== null && tsconfig !== void 0 && (_tsconfig$compilerOpt = tsconfig.compilerOptions) !== null && _tsconfig$compilerOpt !== void 0 && _tsconfig$compilerOpt.allowJs ? ['.ts', '.tsx', '.js', '.jsx'] : ['.ts', '.tsx'];
    } else {
      exts = ['.js', '.jsx'];
    }

    return exts;
  };

  const exts = getExts(isTsProject);
  const globPattern = `${srcDirOrFile}/**/*{${exts.join(',')}}`;

  const files = _utils.glob.sync(globPattern, {
    ignore: [`${srcDirOrFile}/**/*.d.ts`],
    absolute: true
  });

  return files;
};

exports.getWillCompilerCode = getWillCompilerCode;

const buildSourceCode = async config => {
  const {
    compiler,
    willCompilerDirOrFile,
    tsconfigPath,
    sourceMaps,
    babelConfig
  } = config;
  const tsconfig = ts.readTsConfig(tsconfigPath);
  const willCompilerFiles = getWillCompilerCode(willCompilerDirOrFile, {
    tsconfig,
    isTsProject: Boolean(tsconfig)
  });
  let distSet = null;

  if (compiler === Compiler.babel) {
    distSet = await runBabelCompiler(willCompilerFiles, config, _objectSpread(_objectSpread({}, babelConfig), {}, {
      sourceMaps
    }));
  } else {
    distSet = {
      code: 1,
      message: 'no compiler'
    };
  }

  return distSet;
};

exports.buildSourceCode = buildSourceCode;

const generatorRealFiles = virtualDists => {
  for (const virtualDist of virtualDists) {
    const {
      distPath,
      code,
      sourcemap,
      sourceMapPath
    } = virtualDist;

    _utils.fs.ensureFileSync(distPath);

    _utils.fs.writeFileSync(distPath, code);

    if (sourcemap.length > 0) {
      _utils.fs.ensureFileSync(sourceMapPath);

      _utils.fs.writeFileSync(sourceMapPath, sourcemap);
    }
  }
};

const defaultConfig = {
  srcRootDir: `${process.cwd()}/src`,
  willCompilerDirOrFile: `${process.cwd()}/src`,
  distDir: './dist/js/temp',
  compiler: 'babel',
  appDirectory: '',
  sourceMaps: false,
  tsconfigPath: '',
  syntax: 'es5',
  type: 'module',
  watch: false
};

const taskMain = async ({
  modernConfig
}) => {
  // Execution of the script's parameter handling and related required configuration acquisition
  const processArgv = argv(process.argv.slice(2));
  const config = processArgv(defaultConfig);
  process.env.BUILD_FORMAT = (0, _initEnv.initEnv)(config);
  const compiler = Compiler.babel; // Currently, only babel is supported.

  const babelConfig = bc.resolveBabelConfig(config.appDirectory, modernConfig, {
    sourceAbsDir: config.srcRootDir,
    tsconfigPath: config.tsconfigPath,
    syntax: config.syntax,
    type: config.type
  });
  const {
    code,
    message,
    messageDetails,
    virtualDists = []
  } = await buildSourceCode({
    distDir: config.distDir,
    srcRootDir: config.srcRootDir,
    willCompilerDirOrFile: config.willCompilerDirOrFile,
    sourceMaps: config.sourceMaps,
    compiler,
    projectData: {
      appDirectory: config.appDirectory
    },
    tsconfigPath: config.tsconfigPath,
    babelConfig
  });

  if (code === 0) {
    generatorRealFiles(virtualDists); // 执行成功log使用 console.info

    console.info('[Babel Compiler]: Successfully');
  } else if (messageDetails && messageDetails.length > 0) {
    console.error(message);

    for (const detail of messageDetails || []) {
      console.error(detail.content);
    }
  }

  if (code === 0 && config.copyDirs) {
    const copyList = config.copyDirs.split(',');

    for (const copyDir of copyList) {
      _utils.fs.ensureDirSync(copyDir);

      _utils.fs.copySync(config.distDir, copyDir);
    }
  }
};

(async () => {
  let options;

  if (process.env.CORE_INIT_OPTION_FILE) {
    ({
      options
    } = require(process.env.CORE_INIT_OPTION_FILE));
  }

  const {
    resolved
  } = await core.cli.init([], options);
  await core.manager.run(async () => {
    try {
      await taskMain({
        modernConfig: resolved
      });
    } catch (e) {
      console.error(e);
    }
  });
})();