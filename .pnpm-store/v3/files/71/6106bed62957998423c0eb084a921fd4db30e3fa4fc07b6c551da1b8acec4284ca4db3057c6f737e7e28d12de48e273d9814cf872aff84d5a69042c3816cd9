"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseSchema = exports.patchSchema = void 0;
const utils_1 = require("@modern-js/utils");
const lodash_1 = require("@modern-js/utils/lodash");
const source_1 = require("./source");
const output_1 = require("./output");
const server_1 = require("./server");
const deploy_1 = require("./deploy");
const tools_1 = require("./tools");
const debug = (0, utils_1.createDebugger)('validate-schema');
const plugins = {
    type: 'array',
    additionalProperties: false,
};
const dev = {
    type: 'object',
    properties: {
        assetPrefix: { type: ['boolean', 'string'] },
        https: {
            type: 'boolean',
        },
    },
    additionalProperties: false,
};
const patchSchema = (pluginSchemas) => {
    const finalSchema = (0, lodash_1.cloneDeep)({
        type: 'object',
        additionalProperties: false,
        properties: {
            source: source_1.source,
            output: output_1.output,
            server: server_1.server,
            deploy: deploy_1.deploy,
            plugins,
            dev,
            tools: tools_1.tools,
        },
    });
    const findTargetNode = (props) => {
        let node = finalSchema.properties;
        for (const prop of props) {
            node = node[prop];
            if (!node || !(0, utils_1.isObject)(node)) {
                throw new Error(`add schema ${props.join('.')} error`);
            }
            node.properties = node.hasOwnProperty('properties')
                ? node.properties
                : {};
            node = node.properties;
        }
        return node;
    };
    const finalPluginSchemas = [];
    pluginSchemas.forEach(item => {
        if (Array.isArray(item)) {
            finalPluginSchemas.push(...item);
        }
        else {
            finalPluginSchemas.push(item);
        }
    });
    for (const { target, schema } of finalPluginSchemas) {
        if (!target) {
            throw new Error(`should return target property in plugin schema.`);
        }
        const props = target.split('.');
        const mountProperty = props.pop();
        const targetNode = findTargetNode(props);
        if (!targetNode.hasOwnProperty(mountProperty)) {
            targetNode[mountProperty] = (0, lodash_1.cloneDeep)(schema);
        }
    }
    debug(`final validate schema: %o`, finalSchema);
    return finalSchema;
};
exports.patchSchema = patchSchema;
const traverseSchema = (schema) => {
    const keys = [];
    const traverse = ({ properties }, old = []) => {
        for (const key of Object.keys(properties)) {
            const current = [...old, key];
            if (properties[key].type === 'object' && properties[key].properties) {
                traverse(properties[key], current);
            }
            else {
                keys.push(current.join('.'));
            }
        }
    };
    traverse(schema);
    return keys;
};
exports.traverseSchema = traverseSchema;
