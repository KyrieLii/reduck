import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { createAsyncPipeline, useContainer } from "../farrow-pipeline";
var ASYNC_WATERFALL_SYMBOL = Symbol["for"]('MODERN_ASYNC_WATERFALL');
export var getAsyncBrook = function getAsyncBrook(input) {
  if (typeof input === 'function') {
    return input;
  } else if (input && typeof input.middleware === 'function') {
    return input.middleware;
  }

  throw new Error("".concat(input, " is not a AsyncBrook or { brook: AsyncBrook }"));
};
export var createAsyncWaterfall = function createAsyncWaterfall() {
  var pipeline = createAsyncPipeline();

  var use = function use() {
    for (var _len = arguments.length, input = new Array(_len), _key = 0; _key < _len; _key++) {
      input[_key] = arguments[_key];
    }

    pipeline.use.apply(pipeline, _toConsumableArray(input.map(getAsyncBrook).map(mapAsyncBrookToAsyncMiddleware)));
    return waterfall;
  };

  var run = function run(input, options) {
    return pipeline.run(input, _objectSpread(_objectSpread({}, options), {}, {
      onLast: function onLast(input) {
        return input;
      }
    }));
  };

  var middleware = function middleware(input) {
    var container = useContainer();
    return pipeline.run(input, {
      container: container,
      onLast: function onLast(input) {
        return input;
      }
    });
  };

  var waterfall = _objectSpread(_objectSpread({}, pipeline), {}, _defineProperty({
    use: use,
    run: run,
    middleware: middleware
  }, ASYNC_WATERFALL_SYMBOL, true));

  return waterfall;
};
export var isAsyncWaterfall = function isAsyncWaterfall(input) {
  return Boolean(input === null || input === void 0 ? void 0 : input[ASYNC_WATERFALL_SYMBOL]);
};

var mapAsyncBrookToAsyncMiddleware = function mapAsyncBrookToAsyncMiddleware(brook) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(input, next) {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = next;
              _context.next = 3;
              return brook(input);

            case 3:
              _context.t1 = _context.sent;
              return _context.abrupt("return", (0, _context.t0)(_context.t1));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
};