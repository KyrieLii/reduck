"use strict";

var _utils = require("@modern-js/utils");

var _utils2 = require("./utils");

const core = _utils.Import.lazy('@modern-js/core', require);

const argv = _utils.Import.lazy('process.argv', require);

const utils = _utils.Import.lazy('./utils', require);

let removeTsconfigPath = '';

const getProjectTsconfig = tsconfigPath => {
  if (!tsconfigPath || !_utils.fs.existsSync(tsconfigPath)) {
    return {};
  }

  return _utils.json5.parse(_utils.fs.readFileSync(tsconfigPath, 'utf-8'));
};

const resolveLog = (childProgress, {
  tsCheck: _tsCheck = false,
  watch: _watch = false
} = {}) => {
  var _childProgress$stdout, _childProgress$stdout2, _childProgress$stderr;

  /**
   * tsc 所有的log信息都是从stdout data 事件中获取
   * 正常模式下，如果有报错信息，交给 resolveLog 后面的逻辑来处理
   * watch 模式下，则使用这里的信息
   */
  (_childProgress$stdout = childProgress.stdout) === null || _childProgress$stdout === void 0 ? void 0 : _childProgress$stdout.on('data', data => {
    if (!_tsCheck) {
      return;
    }

    if (_watch) {
      console.info(data.toString());
    }
  }); // 正常以下内容都不会触发，因为tsc 不会产生以下类型的log信息，不过防止意外情况

  (_childProgress$stdout2 = childProgress.stdout) === null || _childProgress$stdout2 === void 0 ? void 0 : _childProgress$stdout2.on('error', error => {
    console.error(error.message);
  });
  (_childProgress$stderr = childProgress.stderr) === null || _childProgress$stderr === void 0 ? void 0 : _childProgress$stderr.on('data', chunk => {
    console.error(chunk.toString());
  });
};

const generatorDts = async (_, config) => {
  const {
    tsconfigPath,
    distDir,
    sourceDirName = 'src',
    projectData: {
      appDirectory
    },
    tsCheck = false,
    watch = false
  } = config;
  const userTsconfig = getProjectTsconfig(tsconfigPath);
  const willDeleteTsconfigPath = utils.generatorTsConfig(userTsconfig, {
    appDirectory,
    distDir,
    sourceDir: sourceDirName
  });
  removeTsconfigPath = willDeleteTsconfigPath;
  const tscBinFile = (0, _utils2.getTscBinPath)(appDirectory);
  const watchParams = watch ? ['-w'] : [];
  const childProgress = (0, _utils.execa)(tscBinFile, ['-p', willDeleteTsconfigPath, ...watchParams], {
    stdio: 'pipe',
    cwd: appDirectory
  });
  resolveLog(childProgress, {
    tsCheck,
    watch
  });

  try {
    await childProgress;
    console.info('[TSC Compiler]: Successfully');
  } catch (e) {
    if (!tsCheck) {
      console.info(`There are some type warnings, which can be checked by configuring 'output.disableTsChecker = false'`);
    } // 通过使用 execa，可以将 tsc 的 data 类型的报错信息变为异常错误信息
    else if ((0, _utils.isObject)(e) && e.stdout) {
      console.error(e.stdout);
    } else {
      console.error(e);
    }
  }

  _utils.fs.removeSync(willDeleteTsconfigPath);
};

const taskMain = async ({
  modernConfig
}) => {
  const processArgv = argv(process.argv.slice(2));
  const config = processArgv({
    appDirectory: process.cwd(),
    srcDir: 'src',
    distDir: 'dist/types',
    tsconfigPath: './tsconfig.json',
    sourceDirName: 'src'
  });
  const option = {
    srcDir: config.srcDir,
    distDir: config.distDir,
    projectData: {
      appDirectory: config.appDirectory
    },
    tsconfigPath: config.tsconfigPath,
    watch: config.watch,
    tsCheck: config.tsCheck,
    sourceDirName: config.sourceDirName
  };
  await generatorDts(modernConfig, option); // // TODO: watch 模式下无法转换

  utils.resolveAlias(modernConfig, option);
};

(async () => {
  let options;

  if (process.env.CORE_INIT_OPTION_FILE) {
    ({
      options
    } = require(process.env.CORE_INIT_OPTION_FILE));
  }

  const {
    resolved
  } = await core.cli.init([], options);
  await core.manager.run(async () => {
    try {
      await taskMain({
        modernConfig: resolved
      });
    } catch (e) {
      console.error(e.message);

      _utils.fs.removeSync(removeTsconfigPath);
    }
  });
})();