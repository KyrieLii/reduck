function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { EventEmitter } from 'events';
import pMap from 'p-map';
export class TaskRunner extends EventEmitter {
  constructor(tasks, {
    concurrency
  }) {
    super();

    _defineProperty(this, "_tasks", void 0);

    _defineProperty(this, "_concurrency", void 0);

    _defineProperty(this, "_usableConcurrency", void 0);

    _defineProperty(this, "_stopFlag", void 0);

    this._tasks = tasks;
    this._concurrency = concurrency || TaskRunner.DefaultConcurrency;
    this._usableConcurrency = this._concurrency;
    this._stopFlag = false;
  }

  async run() {
    const tasks = this._tasks.splice(0, this._concurrency);

    this._usableConcurrency = this._concurrency - tasks.length;
    await pMap(tasks, async task => {
      await this._runTask(task);
    }, {
      concurrency: tasks.length
    });
  }

  addTask(task) {
    this._tasks.push(task);
  }

  async _runTask(task) {
    if (this._stopFlag) {
      return;
    }

    const emitValue = await task(this._stopTask.bind(this));
    this._usableConcurrency--;
    this.emit(TaskRunner.TASK_FINISH, emitValue);

    if (this._tasks.length > 0) {
      const nextTasks = this._tasks.splice(0, this._usableConcurrency);

      this._usableConcurrency -= nextTasks.length;

      if (nextTasks.length > 0) {
        await pMap(nextTasks, async _task => {
          await this._runTask(_task);
        }, {
          concurrency: nextTasks.length
        });
      }
    }
  }

  _stopTask() {
    this._stopFlag = true;
  }

}

_defineProperty(TaskRunner, "DefaultConcurrency", 10);

_defineProperty(TaskRunner, "TASK_FINISH", 'task-finish');