function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { removeTailSlash } from '@modern-js/utils';
import { match, pathToRegexp } from 'path-to-regexp';
import { toPath } from "../../utils";
import { ModernRoute } from "./route"; // eslint-disable-next-line no-useless-escape

const regCharsDetector = /[^a-zA-Z\-_0-9\/\.]/;
export class RouteMatcher {
  constructor(spec) {
    _defineProperty(this, "spec", void 0);

    _defineProperty(this, "urlPath", '');

    _defineProperty(this, "urlMatcher", void 0);

    _defineProperty(this, "urlReg", void 0);

    this.spec = spec;
    this.setupUrlPath();
  } // generate modern route object


  generate(url) {
    const route = new ModernRoute(this.spec);

    if (this.urlPath) {
      const params = this.parseURLParams(url);
      route.urlPath = toPath(route.urlPath, params);
      route.params = params;
    }

    return route;
  }

  parseURLParams(pathname) {
    if (!this.urlMatcher) {
      return {};
    } else {
      const matchResult = this.urlMatcher(pathname);
      return matchResult.params;
    }
  } // get match url length


  matchLength(pathname) {
    if (!this.urlReg) {
      return this.urlPath.length;
    } else {
      var _result$;

      const result = this.urlReg.exec(pathname);
      return (result === null || result === void 0 ? void 0 : (_result$ = result[0]) === null || _result$ === void 0 ? void 0 : _result$.length) || null;
    }
  } // if match url path


  matchUrlPath(requestUrl) {
    const urlWithoutSlash = requestUrl.endsWith('/') && requestUrl !== '/' ? requestUrl.slice(0, -1) : requestUrl;

    if (this.urlMatcher) {
      return Boolean(this.urlMatcher(urlWithoutSlash));
    } else {
      if (urlWithoutSlash.startsWith(this.urlPath)) {
        // avoid /abcd match /a
        if (this.urlPath !== '/' && urlWithoutSlash.length > this.urlPath.length && !urlWithoutSlash.startsWith(`${this.urlPath}/`)) {
          return false;
        }

        return true;
      }

      return false;
    }
  }

  matchEntry(entryName) {
    return this.spec.entryName === entryName;
  } // compiler urlPath to regexp if necessary


  setupUrlPath() {
    const {
      urlPath
    } = this.spec;
    this.urlPath = urlPath === '/' ? urlPath : removeTailSlash(urlPath);
    const useReg = regCharsDetector.test(urlPath);

    if (useReg) {
      this.urlMatcher = match(urlPath, {
        end: false,
        decode: decodeURIComponent
      });
      this.urlReg = pathToRegexp(urlPath, [], {
        end: false
      });
    }
  }

}