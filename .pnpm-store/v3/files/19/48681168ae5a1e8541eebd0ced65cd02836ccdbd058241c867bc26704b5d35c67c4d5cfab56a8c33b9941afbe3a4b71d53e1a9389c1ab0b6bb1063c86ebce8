"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMetaTags = void 0;
const tagObjectToString = (tagDefinition) => {
    const attributes = Object.keys(tagDefinition.attributes || {})
        .filter(attributeName => tagDefinition.attributes[attributeName] !== false)
        .map(attributeName => {
        if (tagDefinition.attributes[attributeName] === true) {
            return attributeName;
        }
        return `${attributeName}="${tagDefinition.attributes[attributeName]}"`;
    });
    return `<${[tagDefinition.tagName].concat(attributes).join(' ')}>${tagDefinition.innerHTML || ''}${tagDefinition.voidTag ? '' : `</${tagDefinition.tagName}>`}`;
};
const generateMetaTags = (metaOptions) => {
    if (!metaOptions) {
        return '';
    }
    // Make tags self-closing in case of xhtml
    // Turn { "viewport" : "width=500, initial-scale=1" } into
    // [{ name:"viewport" content:"width=500, initial-scale=1" }]
    const metaTagAttributeObjects = Object.keys(metaOptions)
        .map(metaName => {
        const metaTagContent = metaOptions[metaName];
        return typeof metaTagContent === 'string'
            ? {
                name: metaName,
                content: metaTagContent,
            }
            : metaTagContent;
    })
        .filter(attribute => attribute !== false);
    // Turn [{ name:"viewport" content:"width=500, initial-scale=1" }] into
    // the html-webpack-plugin tag structure
    return metaTagAttributeObjects
        .map(metaTagAttributes => {
        if (metaTagAttributes === false) {
            throw new Error('Invalid meta tag');
        }
        return {
            tagName: 'meta',
            voidTag: true,
            attributes: metaTagAttributes,
        };
    })
        .reduce((memo, tagObject) => `${memo}\n${tagObjectToString(tagObject)}`, '');
};
exports.generateMetaTags = generateMetaTags;
