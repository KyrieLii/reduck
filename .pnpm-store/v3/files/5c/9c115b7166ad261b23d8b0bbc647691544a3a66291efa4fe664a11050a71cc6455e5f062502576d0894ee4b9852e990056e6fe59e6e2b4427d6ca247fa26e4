"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runBuildWatchTask = void 0;

var _anymatch = _interopRequireDefault(require("anymatch"));

var _utils = require("@modern-js/utils");

var _multiTasksLog = require("../../log/multi-tasks-log");

var _watchProjectsState = require("./watch-projects-state");

var _cmds = require("./cmds");

var _createTask = require("./create-task");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getIgnored = config => watchFilePath => {
  // 默认忽略 node_modules 的变化和 dist 目录下文件的变化
  const nodeModulesPattern = /(?:^|[\\/])node_modules/g;

  if (nodeModulesPattern.test(watchFilePath) || watchFilePath.includes('dist')) {
    return true;
  }

  if (config.ignoreMaybeChanged) {
    return (0, _anymatch.default)(config.ignoreMaybeChanged)(watchFilePath);
  }

  return false;
};

const runBuildWatchTask = async (projectName, operator, config, taskCmds = _cmds.defaultBuildWatchCmds) => {
  const {
    needInit = true
  } = config;
  const taskLogger = new _multiTasksLog.MultitasksLogger();
  const dependenciesTask = (0, _createTask.createDependenciesTask)(config, taskCmds, taskLogger);
  const devTask = (0, _createTask.createDevTask)(config, taskCmds, taskLogger);
  const fromNodes = operator.getNodeAllDependencyData(projectName);
  const watchedProjectState = new _watchProjectsState.WatchedProjectsState(fromNodes, config);
  const watcher = new _utils.chokidar.FSWatcher({
    persistent: true,
    cwd: config.rootPath,
    followSymlinks: false,
    ignoreInitial: true,
    ignored: getIgnored(config),
    disableGlobbing: true,
    interval: 1000
  });
  watcher.add(watchedProjectState.getWatchedProjectsPath()); // 可能会移除该判断和 neeInit 配置

  if (needInit) {
    await operator.traverseDependenciesToProject(projectName, async currentProject => {
      await dependenciesTask(currentProject);
    });
  }

  await new Promise(resolve => {
    console.info('start watch');
    watcher.on('all', async (eventName, changeFilePath) => {
      // TODO: 错误情况处理
      if (eventName === 'add') {
        watchedProjectState.updateState();
      }

      const changedProject = watchedProjectState.getChangedProject(changeFilePath);

      if (changedProject) {
        await operator.traverseProjectToDependent(changedProject.name, async (currentProject, _, earlyFinish) => {
          // 调试的项目跳过
          if (currentProject.name === projectName) {
            earlyFinish();
            return;
          }

          if (watchedProjectState.watchProjectsName.includes(currentProject.name)) {
            console.info('run build', currentProject.name);
            await dependenciesTask(currentProject);
          }
        }, {
          withSelf: true
        });
        resolve(null);
      } else {
        console.info('changed is not in monorepo manager');
      }
    });
    resolve(null);
  }); // 执行目标项目的 dev 任务

  await devTask(operator.getNodeData(projectName, {
    checkExist: true
  }));
};

exports.runBuildWatchTask = runBuildWatchTask;