import invariant from 'invariant';

/**
 * Calc id from string or object
 */
const createGetId = () => {
  const idCache = new Map();
  return objectId => {
    const cachedId = idCache.get(objectId);

    if (cachedId) {
      return cachedId;
    } // WARNING: id should be unique after serialize.


    const id = JSON.stringify(objectId);
    invariant(id, 'params should be not null value');
    idCache.set(objectId, id);
    return id;
  };
};

export let LoaderStatus;

(function (LoaderStatus) {
  LoaderStatus[LoaderStatus["idle"] = 0] = "idle";
  LoaderStatus[LoaderStatus["loading"] = 1] = "loading";
  LoaderStatus[LoaderStatus["fulfilled"] = 2] = "fulfilled";
  LoaderStatus[LoaderStatus["rejected"] = 3] = "rejected";
})(LoaderStatus || (LoaderStatus = {}));

const createLoader = (id, initialData = {
  loading: false,
  reloading: false,
  data: undefined,
  error: undefined
}, loaderFn, skip = false) => {
  let promise;
  let status = LoaderStatus.idle;
  let {
    data,
    error
  } = initialData;
  let hasLoaded = false;
  const handlers = new Set();

  const load = async () => {
    if (skip) {
      return promise;
    }

    if (status === LoaderStatus.loading) {
      return promise;
    }

    status = LoaderStatus.loading;
    notify();
    promise = new Promise(resolve => {
      loaderFn().then(value => {
        data = value;
        error = null;
        status = LoaderStatus.fulfilled;
        notify();
        resolve(value);
      }).catch(e => {
        error = e;
        data = null;
        status = LoaderStatus.rejected;
        notify();
        resolve(e);
      }).finally(() => {
        promise = null;
        hasLoaded = true;
      });
    });
    return promise;
  };

  const getResult = () => ({
    loading: !hasLoaded && status === LoaderStatus.loading,
    reloading: hasLoaded && status === LoaderStatus.loading,
    data,
    error: error instanceof Error ? `${error.message}` : error,
    // redundant fields for ssr log
    _error: error
  });

  const notify = () => {
    handlers.forEach(handler => {
      handler(status, getResult());
    });
  };

  const onChange = handler => {
    handlers.add(handler);
    return () => {
      handlers.delete(handler);
    };
  };

  return {
    get result() {
      return getResult();
    },

    get promise() {
      return promise;
    },

    onChange,
    load
  };
};

/**
 * Create loaders manager. It's returned instance will add to context
 * @param initialDataMap used to initialing loader data
 */
export const createLoaderManager = (initialDataMap, managerOptions = {}) => {
  const {
    skipStatic = false,
    skipNonStatic = false
  } = managerOptions;
  const loadersMap = new Map();
  const getId = createGetId();

  const add = (loaderFn, loaderOptions) => {
    const id = getId(loaderOptions.params);
    let loader = loadersMap.get(id);

    if (!loader) {
      // ignore non-static loader on static phase
      const ignoreNonStatic = skipNonStatic && !loaderOptions.static; // ignore static loader on non-static phase

      const ignoreStatic = skipStatic && loaderOptions.static;
      const skipExec = ignoreNonStatic || ignoreStatic;
      loader = createLoader(id, typeof initialDataMap[id] !== 'undefined' ? initialDataMap[id] : {
        data: loaderOptions.initialData
      }, loaderFn, // Todo whether static loader is exec when CSR
      skipExec);
      loadersMap.set(id, loader);
    }

    return id;
  };

  const get = id => loadersMap.get(id); // check if there has pending loaders


  const hasPendingLoaders = () => {
    for (const loader of loadersMap.values()) {
      const {
        promise
      } = loader;

      if (promise instanceof Promise) {
        return true;
      }
    }

    return false;
  }; // waiting for all pending loaders to be settled


  const awaitPendingLoaders = async () => {
    const pendingLoaders = [];

    for (const [id, loader] of loadersMap) {
      const {
        promise
      } = loader;

      if (promise instanceof Promise) {
        pendingLoaders.push([id, loader]);
      }
    }

    await Promise.all(pendingLoaders.map(item => item[1].promise));
    return pendingLoaders.reduce((res, [id, loader]) => {
      res[id] = loader.result;
      return res;
    }, {});
  };

  return {
    hasPendingLoaders,
    awaitPendingLoaders,
    add,
    get
  };
};