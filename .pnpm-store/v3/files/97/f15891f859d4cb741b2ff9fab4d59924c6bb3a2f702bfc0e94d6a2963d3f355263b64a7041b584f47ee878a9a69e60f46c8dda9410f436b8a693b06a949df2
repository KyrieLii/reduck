"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateApi = exports.PREFIX_COMMENT = exports.getFieldsType = exports.getFieldType = exports.isInlineType = void 0;
var tslib_1 = require("tslib");
var formatter_1 = require("farrow-schema/formatter");
var isInlineType = function (input) {
    if ((0, formatter_1.isNamedFormatType)(input)) {
        return !input.name;
    }
    return true;
};
exports.isInlineType = isInlineType;
var getTypeName = function (input) {
    if ((0, formatter_1.isNamedFormatType)(input) && input.name) {
        return input.name;
    }
    return null;
};
var transformComment = function (text) {
    return text
        .split('\n')
        .map(function (item) { return item.trim(); })
        .filter(Boolean)
        .join('\n*\n* ');
};
var attachComment = function (result, options) {
    var list = Object.entries(options)
        .map(function (_a) {
        var _b = (0, tslib_1.__read)(_a, 2), key = _b[0], value = _b[1];
        return value ? "* @".concat(key, " ").concat(transformComment(value.trim())) : '';
    })
        .filter(Boolean);
    if (list.length === 0)
        return result;
    var comment = "/**\n".concat(list.join('\n'), "\n*/\n");
    return comment + result;
};
var getTypeNameById = function (typeId) {
    return "Type".concat(typeId);
};
var getFieldType = function (typeId, types) {
    var fieldType = types[typeId];
    var typeName = getTypeName(fieldType);
    if (typeName) {
        return typeName;
    }
    if (!(0, exports.isInlineType)(fieldType)) {
        return getTypeNameById(typeId);
    }
    if (fieldType.type === 'Scalar') {
        return fieldType.valueType;
    }
    if (fieldType.type === 'Record') {
        return "Record<string, ".concat((0, exports.getFieldType)(fieldType.valueTypeId, types), ">");
    }
    if (fieldType.type === 'Literal') {
        var literal = typeof fieldType.value === 'string' ? "\"".concat(fieldType.value, "\"") : fieldType.value;
        return "".concat(literal);
    }
    if (fieldType.type === 'Nullable') {
        return "".concat((0, exports.getFieldType)(fieldType.itemTypeId, types), " | null | undefined");
    }
    if (fieldType.type === 'List') {
        return "(".concat((0, exports.getFieldType)(fieldType.itemTypeId, types), ")[]");
    }
    if (fieldType.type === 'Union') {
        return fieldType.itemTypes.map(function (itemType) { return (0, exports.getFieldType)(itemType.typeId, types); }).join(' | ');
    }
    if (fieldType.type === 'Intersect') {
        return fieldType.itemTypes.map(function (itemType) { return (0, exports.getFieldType)(itemType.typeId, types); }).join(' & ');
    }
    if (fieldType.type === 'Struct') {
        return "{\n      ".concat((0, exports.getFieldsType)(fieldType.fields, types).join(',\n'), "\n    }");
    }
    if (fieldType.type === 'Strict' ||
        fieldType.type === 'NonStrict' ||
        fieldType.type === 'ReadOnly' ||
        fieldType.type === 'ReadOnlyDeep') {
        return (0, exports.getFieldType)(fieldType.itemTypeId, types);
    }
    if (fieldType.type === 'Tuple') {
        return "[".concat(fieldType.itemTypes.map(function (itemType) { return (0, exports.getFieldType)(itemType.typeId, types); }).join(', '), "]");
    }
    throw new Error("Unsupported field: ".concat(JSON.stringify(fieldType, null, 2)));
};
exports.getFieldType = getFieldType;
var getFieldsType = function (fields, types) {
    return Object.entries(fields).map(function (_a) {
        var _b = (0, tslib_1.__read)(_a, 2), key = _b[0], field = _b[1];
        var fieldType = types[field.typeId];
        var result = '';
        if (fieldType.type === 'Nullable') {
            result = "".concat(key, "?: ").concat((0, exports.getFieldType)(field.typeId, types));
        }
        else {
            result = "".concat(key, ": ").concat((0, exports.getFieldType)(field.typeId, types));
        }
        return attachComment(result, {
            remarks: field.description,
            deprecated: field.deprecated,
        });
    });
};
exports.getFieldsType = getFieldsType;
exports.PREFIX_COMMENT = "\n/**\n * This file was generated by farrow-api\n * Don't modify it manually\n */\n";
var generateApi = function (formatResult, options) {
    var exportSet = new Set();
    var handleType = function (formatType) {
        if ((0, exports.isInlineType)(formatType)) {
            return '';
        }
        if (formatType.type === 'Object' || formatType.type === 'Struct') {
            var typeName = formatType.name;
            var fields = (0, exports.getFieldsType)(formatType.fields, formatResult.types);
            if (!typeName) {
                throw new Error("Empty name of Object/Struct, fields: {".concat(Object.keys(formatType.fields), "}"));
            }
            if (exportSet.has(typeName)) {
                throw new Error("Duplicate Object/Struct type name: ".concat(typeName));
            }
            exportSet.add(typeName);
            return "\n      /**\n       * {@label ".concat(typeName, "} \n       */\n      export type ").concat(typeName, " = {\n        ").concat(fields.join(',  \n'), "\n      }\n      ");
        }
        if (formatType.type === 'Union') {
            var typeName = formatType.name;
            var expression = formatType.itemTypes
                .map(function (itemType) { return (0, exports.getFieldType)(itemType.typeId, formatResult.types); })
                .join(' | ');
            return "\n      /**\n       * {@label ".concat(typeName, "} \n       */\n      export type ").concat(typeName, " = ").concat(expression, "\n      ");
        }
        if (formatType.type === 'Intersect') {
            var typeName = formatType.name;
            var expression = formatType.itemTypes
                .map(function (itemType) { return (0, exports.getFieldType)(itemType.typeId, formatResult.types); })
                .join(' & ');
            return "\n      /**\n       * {@label ".concat(typeName, "} \n       */\n      export type ").concat(typeName, " = ").concat(expression, "\n      ");
        }
        if (formatType.type === 'Tuple') {
            var typeName = formatType.name;
            var expression = "[".concat(formatType.itemTypes
                .map(function (itemType) { return (0, exports.getFieldType)(itemType.typeId, formatResult.types); })
                .join(', '), "]");
            return "\n        /**\n         * {@label ".concat(typeName, "} \n         */\n        export type ").concat(typeName, " = ").concat(expression, "\n        ");
        }
        throw new Error("Unsupported type of ".concat(JSON.stringify(formatType, null, 2)));
    };
    var handleTypes = function (formatTypes) {
        return Object.values(formatTypes).map(function (formatType) { return handleType(formatType); });
    };
    var importStatements = [];
    var typeDeclarations = handleTypes(formatResult.types);
    if (typeDeclarations.some(function (typeDeclaration) { return typeDeclaration.includes('JsonType'); })) {
        importStatements.unshift("import type { JsonType } from 'farrow-api'");
    }
    var variableDeclarations = [];
    var helpers = (options === null || options === void 0 ? void 0 : options.apiClientHelpers) || null;
    if (helpers) {
        importStatements.push.apply(importStatements, (0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(helpers.importStatements(formatResult, options)), false));
        typeDeclarations.push.apply(typeDeclarations, (0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(helpers.typeDeclarations(formatResult, options)), false));
        variableDeclarations.push.apply(variableDeclarations, (0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(helpers.variableDeclarations(formatResult, options)), false));
        var handleApi_1 = function (api, path) {
            return "(".concat(helpers.apiFunctionParams(api, path, formatResult, options), ") => ").concat(helpers.apiFunctionBody(api, path, formatResult, options));
        };
        var handleEntries_1 = function (entries, path) {
            if (path === void 0) { path = []; }
            var fields = Object.entries(entries.entries).map(function (_a) {
                var _b;
                var _c = (0, tslib_1.__read)(_a, 2), key = _c[0], field = _c[1];
                if (field.type === 'Api') {
                    var sourceText = handleApi_1(field, (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(path), false), [key], false));
                    var result = "".concat(key, ": ").concat(sourceText);
                    return attachComment(result, (_b = {
                            remarks: field.description,
                            deprecated: field.deprecated
                        },
                        _b["param input -"] = field.input.description,
                        _b.returns = field.output.description,
                        _b));
                }
                return "".concat(key, ": ").concat(handleEntries_1(field, (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(path), false), [key], false)));
            });
            return "{ ".concat(fields.join(',\n'), " }");
        };
        variableDeclarations.push("export const api = ".concat(handleEntries_1(formatResult.entries)));
    }
    var blocks = [importStatements.join('\n'), typeDeclarations.join('\n\n'), variableDeclarations.join('\n\n')];
    var source = exports.PREFIX_COMMENT + blocks.join('\n\n');
    if (options === null || options === void 0 ? void 0 : options.noCheck) {
        if (typeof options.noCheck === 'string') {
            source = "\n      // @ts-nocheck ".concat(options.noCheck, "\n      ").concat(source, "\n      ");
        }
        else {
            source = "\n      // @ts-nocheck\n      ".concat(source, "\n      ");
        }
    }
    return source;
};
exports.generateApi = generateApi;
//# sourceMappingURL=generateApi.js.map