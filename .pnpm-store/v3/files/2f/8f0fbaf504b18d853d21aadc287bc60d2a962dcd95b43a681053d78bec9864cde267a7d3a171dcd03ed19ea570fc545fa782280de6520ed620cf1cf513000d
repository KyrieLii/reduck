"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runBuildWatch = exports.buildWatch = exports.BuildWatchEvent = exports.BuildWatchEmitter = void 0;

var path = _interopRequireWildcard(require("path"));

var Event = _interopRequireWildcard(require("events"));

var _utils = require("@modern-js/utils");

var _build = require("./build");

var _compilerErrorResult = require("./compilerErrorResult");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const BuildWatchEvent = {
  firstCompiler: 'first-compiler',
  compiling: 'compiling',
  watchingCompiler: 'watching-compiler'
};
exports.BuildWatchEvent = BuildWatchEvent;

class BuildWatchEmitter extends Event.EventEmitter {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "_initFn", void 0);
  }

  setInitFn(fn) {
    this._initFn = fn;
  }

  async watch() {
    if (typeof this._initFn === 'function') {
      return this._initFn(this);
    }

    return null;
  }

}

exports.BuildWatchEmitter = BuildWatchEmitter;

const runBuildWatch = async (option, babelConfig = {}, emitter) => {
  emitter.emit(BuildWatchEvent.compiling);
  const errorResult = new _compilerErrorResult.CompilerErrorResult();
  const watchDir = option.watchDir;
  const {
    distDir,
    quiet
  } = option; // 第一次正常构建

  const firstBuildResult = await (0, _build.build)(option, babelConfig);
  const {
    code
  } = firstBuildResult;

  if (code === 1) {
    errorResult.init(firstBuildResult);
    emitter.emit(BuildWatchEvent.firstCompiler, errorResult.value);
  } else {
    emitter.emit(BuildWatchEvent.firstCompiler, firstBuildResult);
  }

  return (0, _utils.watch)(`${watchDir}/**/*.{js,jsx,ts,tsx}`, async ({
    changeType,
    changedFilePath
  }) => {
    emitter.emit(BuildWatchEvent.compiling);

    if (changeType === _utils.WatchChangeType.UNLINK) {
      const removeFiles = [path.normalize(`./${distDir}/${path.relative(watchDir, changedFilePath)}`)];

      if (!quiet) {
        _utils.logger.info(`remove file: ${removeFiles.join(',')}`);
      }

      const result = {
        code: 0,
        message: `remove file: ${removeFiles.join(',')}`,
        removeFiles
      };
      emitter.emit(BuildWatchEvent.watchingCompiler, result);
      return;
    }

    const result = await (0, _build.build)(_objectSpread(_objectSpread({}, option), {}, {
      filenames: [changedFilePath]
    }), babelConfig);

    if (result.code === 1) {
      errorResult.update(result.messageDetails || []);
      emitter.emit(BuildWatchEvent.watchingCompiler, errorResult.value);
      !quiet && _utils.logger.info(errorResult.value.message);
    } else {
      errorResult.removeByFileName(changedFilePath); // 如果该文件没有报错，则更新该文件状态并检查是否还存在其他报错文件

      if (errorResult.checkExistError()) {
        emitter.emit(BuildWatchEvent.watchingCompiler, _objectSpread(_objectSpread({}, errorResult.value), {}, {
          virtualDists: result.virtualDists
        }));
        !quiet && _utils.logger.info(errorResult.value.message);
      } else {
        emitter.emit(BuildWatchEvent.watchingCompiler, result);
        !quiet && _utils.logger.info(result.message);
      }
    }
  }, [`${watchDir}/**/*.d.ts`]);
};

exports.runBuildWatch = runBuildWatch;

const buildWatch = (option, babelConfig = {}) => {
  const buildWatchEmitter = new BuildWatchEmitter();
  buildWatchEmitter.setInitFn(runBuildWatch.bind(null, option, babelConfig));
  return buildWatchEmitter;
};

exports.buildWatch = buildWatch;