"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.packageManagerFlag = exports.getWorkspaceFile = exports.getPackageManager = exports.getMonorepoBaseData = exports.findMonorepoRoot = void 0;

var path = _interopRequireWildcard(require("path"));

var _nodeCoreLibrary = require("@rushstack/node-core-library");

var _constants = require("../constants");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const useLerna = monorepoRootPath => {
  if (_nodeCoreLibrary.FileSystem.exists(path.join(monorepoRootPath, _constants.WORKSPACE_FILE.LERNA))) {
    return true;
  }

  return false;
};

const useYarnWorkspaces = monorepoRootPath => {
  if (!_nodeCoreLibrary.FileSystem.exists(path.join(monorepoRootPath, _constants.WORKSPACE_FILE.YARN))) {
    return false;
  }

  const json = _nodeCoreLibrary.JsonFile.load(path.join(monorepoRootPath, _constants.WORKSPACE_FILE.YARN));

  if ('workspaces' in json && json.workspaces.packages) {
    return true;
  }

  return false;
};

const usePnpmWorkspaces = monorepoRootPath => {
  if (_nodeCoreLibrary.FileSystem.exists(path.join(monorepoRootPath, _constants.WORKSPACE_FILE.PNPM))) {
    return true;
  }

  return false;
};

const isMonorepo = monorepoRootPath => {
  if (usePnpmWorkspaces(monorepoRootPath) || useLerna(monorepoRootPath) || useYarnWorkspaces(monorepoRootPath)) {
    return true;
  }

  return false;
};

const findMonorepoRoot = starFindPath => {
  let inMonorepo = false;
  let findPath = starFindPath;

  while (findPath !== '/') {
    if (isMonorepo(findPath)) {
      inMonorepo = true;
      break;
    }

    findPath = path.dirname(findPath);
  }

  return inMonorepo ? findPath : undefined;
};

exports.findMonorepoRoot = findMonorepoRoot;

const getWorkspaceFile = startFindPath => {
  const rootPath = findMonorepoRoot(startFindPath);

  if (!rootPath) {
    throw new Error('[Auto Find Mode]: not find any monorepo workspace file, you can set `packagesMatchs.workspaceFile`');
  }

  if (usePnpmWorkspaces(rootPath)) {
    return _constants.WORKSPACE_FILE.PNPM;
  } else if (useLerna(rootPath)) {
    return _constants.WORKSPACE_FILE.LERNA;
  } else if (useYarnWorkspaces(rootPath)) {
    return _constants.WORKSPACE_FILE.YARN;
  } else {
    throw new Error('[Auto Find Mode]: not find any monorepo workspace file, you can set `packagesMatchs.workspaceFile`');
  }
};

exports.getWorkspaceFile = getWorkspaceFile;
const packageManagerFlag = {
  pnpm: [_constants.WORKSPACE_FILE.PNPM, 'pnpm-lock.yaml'],
  yarn: ['yarn.lock', useYarnWorkspaces],
  npm: [() => true]
};
exports.packageManagerFlag = packageManagerFlag;

const usePnpmPackageManager = monorepoRootPath => packageManagerFlag.pnpm.some(flag => _nodeCoreLibrary.FileSystem.exists(path.join(monorepoRootPath, flag)));

const useYarnPackageManager = monorepoRootPath => packageManagerFlag.yarn.some(flag => {
  if (typeof flag === 'function') {
    return flag(monorepoRootPath);
  }

  return _nodeCoreLibrary.FileSystem.exists(path.join(monorepoRootPath, flag));
});

const getPackageManager = monorepoRootPath => {
  if (usePnpmPackageManager(monorepoRootPath)) {
    return 'pnpm';
  } else if (useYarnPackageManager(monorepoRootPath)) {
    return 'yarn';
  }

  return 'npm';
};

exports.getPackageManager = getPackageManager;

const getMonorepoBaseData = (root = process.cwd()) => {
  const rootPath = findMonorepoRoot(root);

  if (!rootPath) {
    throw new Error('not find any monorepo, you can add lerna„ÄÅpnpm or yarn workspace file');
  }

  return {
    rootPath,
    packageManager: getPackageManager(rootPath)
  };
};

exports.getMonorepoBaseData = getMonorepoBaseData;