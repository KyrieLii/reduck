function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import EventEmitter from 'events';
import { chalk } from '@modern-js/utils';
export const clearFlag = '\x1Bc';
export const logTemplate = (title, messageStack, maxLength, {
  noBottomBorder: _noBottomBorder = false,
  bottomBorderText: _bottomBorderText = '',
  noLeftBorder: _noLeftBorder = false,
  leftBorder: _leftBorder = '│',
  contentColor: _contentColor = s => s
} = {}) => {
  const leftBorderFlag = _noLeftBorder ? '' : _leftBorder;
  const messageFragments = messageStack.map(p => {
    p.trim();
    return `${leftBorderFlag}${p.replace(clearFlag, '')}`;
  }) // 移除 clearFlag
  .filter(s => s !== leftBorderFlag) // 过滤空字符串
  .slice(0, maxLength) // 控制长度
  .reverse(); // 调换顺序，最新的消息在最后面

  messageFragments[messageFragments.length - 1] = messageFragments[messageFragments.length - 1].trim();
  const template = `${title}:
${_contentColor(messageFragments.join(''))}${_noBottomBorder ? '' : `\n${_bottomBorderText}`}`;
  console.info('template', messageFragments);
  return template;
};
export class LoggerText {
  constructor(option) {
    _defineProperty(this, "messages", void 0);

    _defineProperty(this, "option", void 0);

    this.messages = [];
    this.option = option;
  }

  append(message) {
    var _this$option$contentC;

    const replace = ((_this$option$contentC = this.option.contentConfig) === null || _this$option$contentC === void 0 ? void 0 : _this$option$contentC.replace) || [];
    let content = message;

    for (const r of replace) {
      content = content.replace(new RegExp(r, 'g'), '');
    }

    this.messages.push(content);
  }

  get value() {
    const {
      title,
      maxLength,
      contentConfig
    } = this.option;
    const messages = [...new Set(this.messages)];
    return logTemplate(title, messages, maxLength, contentConfig);
  }

}
export class LoggerManager extends EventEmitter {
  // constructor() {}
  createLoggerText(option) {
    return new LoggerText(option);
  }

  addStdout(loggerText, stdout, config = {}) {
    const {
      event = {
        data: true,
        error: true
      },
      colors = {
        data: chalk.green,
        error: chalk.red,
        warning: chalk.yellow
      }
    } = config;

    if (event.data) {
      stdout === null || stdout === void 0 ? void 0 : stdout.on('data', chunk => {
        const data = chunk.toString();
        const content = colors.data ? colors.data(data) : chalk.green(data);
        loggerText.append(content);
        this.emit('data');
      });
    }

    if (event.error) {
      stdout === null || stdout === void 0 ? void 0 : stdout.on('error', error => {
        const data = error.message;
        const content = colors.error ? colors.error(data) : chalk.red(data);
        loggerText.append(content);
        this.emit('data');
      });
    }
  }

  addStderr(loggerText, stderr) {
    stderr === null || stderr === void 0 ? void 0 : stderr.on('data', chunk => {
      const data = chunk.toString();
      loggerText.append(data);
    });
  }

  show(loggerText) {
    console.info(loggerText.value);
  }

}