import path from 'path';
import fs from 'fs';
import { renderToStaticMarkup } from 'react-dom/server';
import { run } from '@modern-js/utils/ssr';
import { LOADABLE_STATS_FILE } from '@modern-js/utils/constants';
import { ChunkExtractor } from '@loadable/server'; // todo: SSRContext

import { jsx as _jsx } from "react/jsx-runtime";

const prefetch = async (App, context) => run(context.ssrContext.request.headers, async () => {
  var _context$store;

  const {
    ssrContext
  } = context;
  const loadablefile = path.resolve(ssrContext.distDir, LOADABLE_STATS_FILE);

  if (fs.existsSync(loadablefile)) {
    const extractor = new ChunkExtractor({
      statsFile: path.resolve(ssrContext.distDir, LOADABLE_STATS_FILE),
      entrypoints: [ssrContext.entryName].filter(Boolean)
    });
    renderToStaticMarkup(extractor.collectChunks( /*#__PURE__*/_jsx(App, {
      context: context
    })));
  } else {
    renderToStaticMarkup( /*#__PURE__*/_jsx(App, {
      context: context
    }));
  }

  if (!context.loaderManager.hasPendingLoaders()) {
    return {
      i18nData: context.__i18nData__
    };
  }

  const loadersData = await context.loaderManager.awaitPendingLoaders();
  Object.keys(loadersData).forEach(id => {
    const data = loadersData[id];

    if (data._error) {
      ssrContext.logger.error('App Prefetch Loader', data._error);
      ssrContext.metrics.emitCounter('app.prefetch.loader.error', 1);
      delete data._error;
    }
  });
  return {
    loadersData,
    i18nData: context.__i18nData__,
    // todo: move to plugin state
    storeState: context === null || context === void 0 ? void 0 : (_context$store = context.store) === null || _context$store === void 0 ? void 0 : _context$store.getState()
  };
});

export default prefetch;