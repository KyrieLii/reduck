function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import path from 'path';
import { getModuleNameMapper, DEFAULT_RESOLVER_PATH } from '@modern-js/testing';
import { isApiOnly } from '@modern-js/utils';
import { bff_info_key } from "./constant";
import { isBFFProject } from "./utils";
export const setJestConfigForBFF = async ({
  pwd,
  userConfig,
  plugins,
  routes,
  utils
}) => {
  var _userConfig$source;

  const bffConfig = {
    rootDir: path.join(pwd, './api'),
    setupFilesAfterEnv: [require.resolve("./setup")],
    testEnvironment: require.resolve("./env"),
    testMatch: [`**/api/**/*.test.[jt]s`],
    globals: {
      [bff_info_key]: {
        appDir: pwd,
        modernUserConfig: userConfig,
        plugins,
        routes
      }
    }
  };
  const {
    jestConfig
  } = utils;
  const alias = (userConfig === null || userConfig === void 0 ? void 0 : (_userConfig$source = userConfig.source) === null || _userConfig$source === void 0 ? void 0 : _userConfig$source.alias) || {};
  const aliasMapper = getModuleNameMapper(alias);
  const {
    transform,
    moduleNameMapper
  } = jestConfig;
  const apiOnly = await isApiOnly(pwd);

  const mergedModuleNameMapper = _objectSpread(_objectSpread({}, moduleNameMapper), aliasMapper);

  const resolver = jestConfig.resolver || DEFAULT_RESOLVER_PATH; // 这三个配置不能设置在 projects 中，需要设置在外层(https://github.com/facebook/jest/issues/9696)

  const configFields = ['coverage', 'collectCoverage', 'testTimeout'];
  const commonConfig = configFields.reduce((obj, field) => {
    if (jestConfig.hasOwnProperty(field)) {
      obj[field] = jestConfig[field];
    }

    return obj;
  }, {});

  if (!apiOnly) {
    utils.setJestConfig({
      projects: [_objectSpread({}, jestConfig), _objectSpread({
        transform,
        moduleNameMapper: mergedModuleNameMapper,
        resolver
      }, bffConfig)]
    }, {
      force: true
    });
  } else {
    utils.setJestConfig({
      projects: [_objectSpread({
        transform,
        moduleNameMapper: mergedModuleNameMapper,
        resolver
      }, bffConfig)]
    }, {
      force: true
    });
  }

  utils.setJestConfig(commonConfig);
};
export default (() => ({
  name: '@modern-js/testing-plugin-bff',

  setup(api) {
    return {
      jestConfig: async (utils, next) => {
        const appContext = api.useAppContext();
        const pwd = appContext.appDirectory;

        if (!isBFFProject(pwd)) {
          return next(utils);
        }

        const userConfig = api.useResolvedConfigContext();
        const plugins = appContext.plugins.map(p => p.server).filter(Boolean);
        await setJestConfigForBFF({
          pwd,
          userConfig,
          plugins,
          routes: appContext.serverRoutes,
          utils
        });
        return next(utils);
      }
    };
  }

}));
export { request as testBff } from "./utils";