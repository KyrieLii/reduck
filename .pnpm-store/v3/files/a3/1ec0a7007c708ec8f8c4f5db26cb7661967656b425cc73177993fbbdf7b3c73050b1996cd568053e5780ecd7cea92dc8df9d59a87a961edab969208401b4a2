{
  "name": "farrow-http",
  "version": "1.12.0",
  "description": "A Type-Friendly Web Framework",
  "main": "dist/index.js",
  "files": [
    "dist",
    "src"
  ],
  "keywords": [
    "Web Framework",
    "TypeScript",
    "Functional Programming"
  ],
  "author": "Jade Gu",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Lucifier129/farrow.git"
  },
  "devDependencies": {
    "@types/accepts": "^1.3.5",
    "@types/bytes": "^3.1.0",
    "@types/co-body": "^5.1.0",
    "@types/content-disposition": "^0.5.3",
    "@types/cookie": "^0.4.0",
    "@types/cookies": "^0.7.6",
    "@types/destroy": "^1.0.0",
    "@types/encodeurl": "^1.0.0",
    "@types/escape-html": "^1.0.0",
    "@types/jest": "^27.0.2",
    "@types/mime-types": "^2.1.0",
    "@types/on-finished": "^2.3.1",
    "@types/qs": "^6.9.5",
    "@types/statuses": "^2.0.0",
    "@types/supertest": "^2.0.11",
    "@types/type-is": "^1.6.3",
    "@types/vary": "^1.1.0",
    "jest": "^27.2.2",
    "supertest": "^6.1.6",
    "ts-jest": "^27.0.5",
    "typescript": "^4.5.4"
  },
  "dependencies": {
    "accepts": "^1.3.7",
    "bytes": "^3.1.0",
    "chalk": "^4.1.0",
    "co-body": "^6.0.0",
    "content-disposition": "^0.5.3",
    "cookie": "^0.4.1",
    "cookies": "^0.8.0",
    "destroy": "^1.0.4",
    "encodeurl": "^1.0.2",
    "escape-html": "^1.0.3",
    "farrow-pipeline": "^1.12.0",
    "farrow-schema": "^1.12.0",
    "mime-types": "^2.1.27",
    "on-finished": "^2.3.0",
    "path-to-regexp": "^6.1.0",
    "qs": "^6.9.6",
    "statuses": "^2.0.0",
    "tslib": "^2.1.0",
    "type-is": "^1.6.18",
    "vary": "^1.1.2"
  },
  "scripts": {
    "build": "tsc -b",
    "test": "jest",
    "test:coverage": "jest --collectCoverage --coverage"
  },
  "readme": "# farrow-http\n\nA Type-Friendly Web Framework\n\n## Table of Content\n\n- [API](#api)\n  - [Http(options?: HttpPipelineOptions): HttpPipeline](#httpoptions-httppipelineoptions-httppipeline)\n  - [Https(options?: HttpsPipelineOptions): HttpsPipeline](#httpsoptions-httpspipelineoptions-httpspipeline)\n  - [Response](#response)\n  - [Router(): RouterPipeline](#router-routerpipeline)\n    - [Router-Url-Schema](#router-url-schema)\n      - [Dynamic parameter](#dynamic-parameter)\n      - [Static parameter](#static-parameter)\n      - [Current supported types in `router-url-schema`](#current-supported-types-in-router-url-schema)\n    - [Routing methods](#routing-methods)\n  - [useReq(): IncomingMessage](#usereq-incomingmessage)\n  - [useRes(): ServerResponse](#useres-serverresponse)\n  - [useRequestInfo(): RequestInfo](#userequestinfo-requestinfo)\n  - [useBasenames(): string[]](#usebasenames-string)\n  - [usePrefix(): string](#useprefix-string)\n\n## API\n\n```typescript\nimport {\n  Http, // use to create http server\n  Https, // use to create https server\n  Response, // use to respond user\n  Router, // use to create router\n  useReq, // farrow-hooks for accessing the original request of node.js http module\n  useRes, // farrow-hooks for accessing the original response of node.js http module\n  useRequestInfo, // farrow-hooks for accessing the request info\n  useBasenames, // farrow-hooks for accessing the basename list\n  usePrefix, // farrow-hooks for accessing the prefix string which is euqal basenames.join('')\n} from 'farrow-http'\n```\n\n### Http(options?: HttpPipelineOptions): HttpPipeline\n\ncreate a http server\n\n```typescript\ntype HttpPipelineOptions = {\n  // basename list, farrow-http will cut the basename from request.pathname\n  basenames?: string[]\n  // options for parsing req body, learn more: https://github.com/cojs/co-body#options\n  body?: BodyOptions\n  // options for parsing req cookies, learn more: https://github.com/jshttp/cookie#options\n  cookie?: CookieOptions\n  // options for parsing req query, learn more: https://github.com/ljharb/qs\n  query?: QueryOptions\n  // injecting contexts per request\n  contexts?: (params: {\n    req: IncomingMessage\n    requestInfo: RequestInfo\n    basename: string\n  }) => ContextStorage | Promise<ContextStorage>\n  // enable log or not\n  logger?: boolean | HttpLoggerOptions\n}\n\n// learn more about RouterPipeline below.\ntype HttpPipeline = RouterPipeline & {\n  // http.handle(req, res), handle request and respond to user, you can use this function to make farrow-http work in expressjs/koajs or other web framework in node.js\n  handle: (req: IncomingMessage, res: ServerResponse) => Promise<void>\n  // the same args of http.createServer().listen(...), create a server and listen to port\n  listen: (...args: Parameters<Server['listen']>) => Server\n  // just create a server with http.handle(req, res), don't listen to any port\n  server: () => Server\n}\n\n// logger options\ntype LoggerOptions = {\n  // handle logger result string\n  transporter?: (str: string) => void\n}\n\ntype HttpLoggerOptions = LoggerOptions & {\n  /**\n   * it should ignore the introspection request log or not\n   * default is true\n   */\n  ignoreIntrospectionRequestOfFarrowApi?: boolean\n}\n```\n\n### Https(options?: HttpsPipelineOptions): HttpsPipeline\n\ncreate a https server\n\n```ts\nexport type HttpsOptions = SecureContextOptions & TlsOptions\n\nexport type HttpsPipelineOptions = HttpPipelineOptions & {\n  // Intersection between options from tls.createServer() and tls.createSecureContext() in Node.js\n  tsl?: HttpsOptions\n}\n\ntype HttpsPipeline = RouterPipeline & {\n  // https.handle(req, res), handle request and respond to user, you can use this function to make farrow-http work in expressjs/koajs or other web framework in node.js\n  handle: (req: IncomingMessage, res: ServerResponse) => Promise<void>\n  // the same args of https.createServer().listen(...), create a server and listen to port\n  listen: (...args: Parameters<Server['listen']>) => Server\n  // just create a server with https.handle(req, res), don't listen to any port\n  server: () => Server\n}\n```\n\n- tls <[HttpsOptions](https://github.com/Lucifier129/farrow/blob/6c0208e0f9e3e3015042caf4f001717750800602/packages/farrow-http/src/https.ts#L22)>\n  Intersection between options from [tls.createServer()](https://nodejs.org/dist/latest-v15.x/docs/api/tls.html#tls_tls_createserver_options_secureconnectionlistener) and [tls.createSecureContext()](https://nodejs.org/dist/latest-v15.x/docs/api/tls.html#tls_tls_createsecurecontext_options) in [Node.js](https://nodejs.org/)\n\n> Notes: Server created by http is different from created by https.\n\n### Response\n\n`Response` can be used to describe the shape of the real server response, farrow-http will perform it later\n\n```typescript\ntype ResponseInfo = {\n  status?: Status\n  headers?: Headers\n  cookies?: Cookies\n  body?: Body\n  vary?: string[]\n}\n\ntype Response = {\n  // response info\n  info: ResponseInfo\n  // check response content type\n  // response.is('json') => 'json' | false\n  is: (...types: string[]) => string | false\n  // merger all responses\n  merge: (...responses: Response[]) => Response\n  // set string response body\n  string: (value: string) => Response\n  // set json response body\n  json: (value: JsonType) => Response\n  // set html response body\n  html: (value: string) => Response\n  // set text response body\n  text: (value: string) => Response\n  // redirect response\n  redirect: (url: string, options?: { usePrefix?: boolean }) => Response\n  // set stream response body\n  stream: (stream: Stream) => Response\n  // set file response body\n  file: (filename: string) => Response\n  // set vary header fields\n  vary: (...fileds: string[]) => Response\n  // set response cookie\n  cookie: (name: string, value: string | number | null, options?: Cookies.SetOption) => Response\n  // set response cookies\n  cookies: (cookies: { [key: string]: string | number | null }, options?: Cookies.SetOption) => Response\n  // set response header\n  header: (name: string, value: Value) => Response\n  // set response headers\n  headers: (headers: Headers) => Response\n  // set response status\n  status: (code: number, message?: string) => Response\n  // set buffer response body\n  buffer: (buffer: Buffer) => Response\n  // set empty content response body\n  empty: () => Response\n  // set attachment response header\n  attachment: (filename?: string) => Response\n  // set custom response body\n  custom: (handler?: CustomBodyHandler) => Response\n  // set content-type via mime-type/extname\n  type: (type: string) => Response\n}\n```\n\n### Router(): RouterPipeline\n\ncreate a router\n\n```typescript\n// learn more about Pipeline from Farrow-Pipeline API: https://github.com/Lucifier129/farrow/blob/master/docs/pipeline.md\ntype RouterPipeline = Pipeline<RequestInfo, MaybeAsyncResponse> & {\n  // capture the response body if the specific type is matched, should returning response in callback function\n  capture: <T extends keyof BodyMap>(type: T, callback: (body: BodyMap[T]) => MaybeAsyncResponse) => void\n  // add sub route and return a route-pipeline which can handle the matched request info\n  route: (name: string) => Pipeline<RequestInfo, MaybeAsyncResponse>\n  // serve static assets\n  serve: (name: string, dirname: string) => void\n  // match specific request via router-request-schema and return a schema-pipeline which can handle the matched request info\n  match: <T extends RouterRequestSchema>(\n    schema: T,\n    options?: MatchOptions,\n  ) => Pipeline<TypeOfRequestSchema<T>, MaybeAsyncResponse>\n}\n\ntype RouterRequestSchema = {\n  // match pathname of req via https://github.com/pillarjs/path-to-regexp\n  pathname: Pathname\n  // match method of req.method, default is GET, supports multiple methods as array\n  method?: string | string[]\n  // match the params parsed by path-to-regexp\n  params?: RouterSchemaDescriptor\n  // match the req query\n  query?: RouterSchemaDescriptor\n  // match the req body\n  body?: Schema.FieldDescriptor | Schema.FieldDescriptors\n  // match the req headers\n  headers?: RouterSchemaDescriptor\n  // match the req cookies\n  cookies?: RouterSchemaDescriptor\n}\n\ntype MatchOptions = {\n  // if true, it will throw error when there are no middlewares handle the request, or it will calling next()\n  block?: boolean\n  // if given, it will be called when Router-Request-Schema was failed, if it returned Response in sync or async way, that would be the final response of middleware\n  onSchemaError?(error: ValidationError): Response | void | Promise<Response | void>\n}\n\nconst router = Router()\n\n// all fileds of router-request-schema list below\n// learn more about Schema Builder from Farrow-Schema API: https://github.com/Lucifier129/farrow/blob/master/docs/schema.md\nrouter\n  .match({\n    pathname: '/product/:id',\n    method: 'POST',\n    params: {\n      id: Number,\n    },\n    query: {\n      a: Number,\n      b: String,\n      c: Boolean,\n    },\n    body: {\n      a: Number,\n      b: String,\n      c: Boolean,\n    },\n    headers: {\n      a: Number,\n      b: String,\n      c: Boolean,\n    },\n    cookies: {\n      a: Number,\n      b: String,\n      c: Boolean,\n    },\n  })\n  .use(async (request) => {\n    console.log('request', request)\n  })\n```\n\n#### Router-Url-Schema\n\nSince farrow `v1.2.0`, a new feature `router-url-schema` is supported. it combines `{ pathname, params, query }` into `{ url }`, and use [Template literal types](https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#template-literal-types) to extract the type info\n\n```typescript\n// the same schema as above but in a more compact form\nrouter\n  .match({\n    url: '/product/<id:number>?<a:number>&<b:string>&<c:boolean>',\n    method: 'POST',\n    body: {\n      a: Number,\n      b: String,\n      c: Boolean,\n    },\n    headers: {\n      a: Number,\n      b: String,\n      c: Boolean,\n    },\n    cookies: {\n      a: Number,\n      b: String,\n      c: Boolean,\n    },\n  })\n  .use(async (request) => {\n    console.log('request', request)\n  })\n```\n\n##### Dynamic parameter\n\nA dynamic parameter has the form `<key:type>`.\n\n- if it was placed in `pathname`(before `?` in a url), it will regard as `params[key] = type`. the order is matter\n- if it was placed in `querystring`(after `?` in a url), it will regard as `query[key] = type`. the order is't matter\n\nDynamic parameter support `modifier`(learn more from [here](https://github.com/pillarjs/path-to-regexp#modifiers)), has the form:\n\n- `<key?:type>` means optional, the corresponding type is `{ key?: type }`, the corresponding pattern is `/:key?`\n- `<key*:type>` means zero or more, the corresponding type is `{ key?: type[] }`, the corresponding pattern is `/:key*`\n- `<key+:type>` means one or more, the corresponding type is `{ key: type[] }`, the corresponding pattern is `/:key+`\n\n##### Static parameter\n\nA static parameter can only be placed in `querystring`, it will regard as `literal string type`.\n\nFor example: `/?<a:int>&b=2` has the type `{ pathname: string, query: { a: number, b: '2' } }`\n\n##### Current supported types in `router-url-schema`\n\nThe supported types in `<key:type>` are list below:\n\n- `string` -> ts `string`\n- `number` -> ts `number`\n- `boolean` -> ts `boolean`\n- `id` -> ts `string`, but `farrow-schema` will ensure it's not empty\n- `int` -> ts `number`, but `farrow-schema` will ensure it's integer\n- `float` -> ts `number`\n- `{*+}` -> use the string wrapped by `{}` as `string literal type`. eg. `{abc}` has type `\"abc\"`, only `string literal type` is supported\n- `|` -> ts `union types`. eg. `<a:int|boolean|string>` has ts type `number|boolean|string`\n\n#### Routing methods\n\n`router[get|post|put|patch|head|delte|options](url, schema?, options?)` is supported as shortcut of `router.match({ url, method: get|post|put|patch|head|delte|options }, options?)`\n\n```typescript\nrouter.get('/get0/<arg0:int>?<arg1:int>').use((request) => {\n  return Response.json({\n    type: 'get',\n    request,\n  })\n})\n```\n\n### useReq(): IncomingMessage\n\n```typescript\nhttp.use(() => {\n  // original request\n  let req = useReq()\n})\n```\n\n### useRes(): ServerResponse\n\n```typescript\nhttp.use(() => {\n  // original response\n  let res = useRes()\n})\n```\n\n### useRequestInfo(): RequestInfo\n\n```typescript\nhttp.use((request0) => {\n  // request1 in here is equal to request0, but we can calling useRequestInfo in any custom hooks\n  let request1 = useRequestInfo()\n})\n```\n\n### useBasenames(): string[]\n\n```typescript\nconst http = Http({\n  basenames: ['/base0'],\n})\nhttp.route('/base1').use(() => {\n  // basenames will be ['/base0', '/base1'] if user accessed /base0/base1\n  let basenames = useBasenames().value\n  return Response.json({ basenames })\n})\n```\n\n### usePrefix(): string\n\n```typescript\nconst http = Http({\n  basenames: ['/base0'],\n})\n\nhttp.route('/base1').use(() => {\n  // prefix will be '/base0/base1' if user accessed /base0/base1\n  let prefix = usePrefix()\n  return Response.json({ prefix })\n})\n```\n"
}