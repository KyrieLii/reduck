"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformDtsAlias = void 0;

var path = _interopRequireWildcard(require("path"));

var parser = _interopRequireWildcard(require("@babel/parser"));

var _traverse = _interopRequireDefault(require("@babel/traverse"));

var _generator = _interopRequireDefault(require("@babel/generator"));

var t = _interopRequireWildcard(require("@babel/types"));

var _tsconfigPaths = require("@modern-js/utils/tsconfig-paths");

var _utils = require("@modern-js/utils");

var _constants = require("./constants");

var _utils2 = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const getPathsMap = (paths, sourceDirName = 'src') => {
  const pathKeys = Object.keys(paths);
  const pathsMap = {};

  const replaceSrcToTypes = s => s.replace(sourceDirName, 'types');

  for (const key of pathKeys) {
    const p = paths[key];

    if (typeof p === 'string') {
      pathsMap[key] = [replaceSrcToTypes(p)];
    } else {
      pathsMap[key] = paths[key].map(sp => replaceSrcToTypes(sp));
    }
  }

  return pathsMap;
};

function mapPathString(nodePath, {
  filename,
  baseUrl,
  paths
}) {
  if (!t.isStringLiteral(nodePath)) {
    return;
  }

  const sourcePath = nodePath.node.value;
  const currentFile = filename;
  const pathsMap = getPathsMap(paths);
  const matchPath = (0, _tsconfigPaths.createMatchPath)(baseUrl, pathsMap, ['index']);
  const result = matchPath(sourcePath, packageJsonPath => {
    if (!_utils.fs.existsSync(packageJsonPath)) {
      return undefined;
    }

    return _utils.fs.readJSONSync(packageJsonPath);
  }, filePath => _utils.fs.existsSync(filePath), ['.d.ts']);

  if (result) {
    const relativePath = path.relative(path.dirname(currentFile), path.dirname(result));
    const fileName = path.basename(result); // 如果是同级文件，则返回的是 ''

    const filePath = path.normalize(`${relativePath.length === 0 ? '.' : relativePath}/${fileName}`);
    const replaceString = filePath.startsWith('.') ? filePath : `./${filePath}`;
    nodePath.replaceWith(t.stringLiteral(replaceString));
  }
}

const transformCall = option => nodePath => {
  const calleePath = nodePath.get('callee');

  const isNormalCall = _constants.defaultTransformedFunctions.some(pattern => (0, _utils2.matchesPattern)(calleePath, pattern));

  if (isNormalCall || (0, _utils2.isImportCall)(nodePath)) {
    mapPathString(nodePath.get('arguments.0'), option);
  }
};

const transformImport = option => nodePath => {
  mapPathString(nodePath.get('source'), option);
};

const transformExport = option => nodePath => {
  mapPathString(nodePath.get('source'), option);
};

const transformSingleFileAlias = ({
  filename,
  baseUrl,
  paths
}) => {
  const sourceCode = _utils.fs.readFileSync(filename, 'utf-8');

  const ast = parser.parse(sourceCode, {
    sourceType: 'module',
    errorRecovery: true,
    // 防止typescript不支持的语法出现而报错
    plugins: ['typescript']
  });
  (0, _traverse.default)(ast, {
    CallExpression: transformCall({
      filename,
      baseUrl,
      paths
    }),
    ImportDeclaration: transformImport({
      filename,
      baseUrl,
      paths
    }),
    ExportDeclaration: transformExport({
      filename,
      baseUrl,
      paths
    })
  });
  return (0, _generator.default)(ast).code;
};

const transformDtsAlias = option => {
  const {
    filenames = [],
    baseUrl,
    paths
  } = option;
  const transformResult = [];

  for (const filename of filenames) {
    transformResult.push({
      path: filename,
      content: transformSingleFileAlias({
        filename,
        baseUrl,
        paths
      })
    });
  }

  return transformResult;
};

exports.transformDtsAlias = transformDtsAlias;