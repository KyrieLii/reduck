function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { isPipeline, createPipeline, runWithContainer, createContainer } from "../farrow-pipeline";
import { isWaterfall, createWaterfall, isAsyncWaterfall, createAsyncWaterfall } from "../waterfall";
import { isWorkflow, createWorkflow, isAsyncWorkflow, createAsyncWorkflow, isParallelWorkflow, createParallelWorkflow } from "../workflow";
import { RunnerContext, useRunner } from "./runner";
const SYNC_PLUGIN_SYMBOL = 'SYNC_PLUGIN_SYMBOL';
export const DEFAULT_OPTIONS = {
  name: 'untitled',
  pre: [],
  post: [],
  rivals: [],
  required: [],
  usePlugins: [],
  registerHook: {}
};
export const createManager = (hooks, api) => {
  let index = 0;

  let currentHooks = _objectSpread({}, hooks);

  const registerHook = extraHooks => {
    currentHooks = _objectSpread(_objectSpread({}, extraHooks), currentHooks);
  };

  const isPlugin = input => isObject(input) && hasOwnProperty(input, SYNC_PLUGIN_SYMBOL) && input[SYNC_PLUGIN_SYMBOL] === SYNC_PLUGIN_SYMBOL;

  const pluginAPI = _objectSpread(_objectSpread({}, api), {}, {
    useHookRunners: useRunner
  });

  const clone = overrideAPI => {
    let plugins = [];

    const addPlugin = plugin => {
      if (!includePlugin(plugins, plugin)) {
        plugins.push(_objectSpread({}, plugin));
      }
    };

    const usePlugin = (...input) => {
      for (const plugin of input) {
        // already created by createPlugin
        if (isPlugin(plugin)) {
          addPlugin(plugin);
        } // using function to return plugin options
        else if (typeof plugin === 'function') {
          const options = plugin();
          addPlugin(createPlugin(options.setup, options));
        } // plain plugin object
        else if (isObject(plugin)) {
          addPlugin(createPlugin(plugin.setup, plugin));
        } // unknown plugin
        else {
          console.warn(`Unknown plugin: ${JSON.stringify(plugin)}`);
        }
      }

      return manager;
    };

    const createPlugin = ( // eslint-disable-next-line @typescript-eslint/no-empty-function
    setup = () => {}, options = {}) => {
      var _options$usePlugins;

      if ((_options$usePlugins = options.usePlugins) !== null && _options$usePlugins !== void 0 && _options$usePlugins.length) {
        options.usePlugins.forEach(plugin => {
          usePlugin(createPlugin(plugin.setup, plugin));
        });
      }

      if (options.registerHook) {
        registerHook(options.registerHook);
      }

      return _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_OPTIONS), {}, {
        name: `No.${index++} plugin`
      }, options), {}, {
        SYNC_PLUGIN_SYMBOL,
        setup
      });
    };

    const clear = () => {
      plugins = [];
    };

    const currentContainer = createContainer();

    const init = options => {
      const container = (options === null || options === void 0 ? void 0 : options.container) || currentContainer;
      const sortedPlugins = sortPlugins(plugins);

      const mergedPluginAPI = _objectSpread(_objectSpread({}, pluginAPI), overrideAPI);

      checkPlugins(sortedPlugins);
      const hooksList = sortedPlugins.map(plugin => runWithContainer(() => plugin.setup(mergedPluginAPI), container));
      return generateRunner(hooksList, container, currentHooks);
    };

    const run = (cb, options) => {
      const container = (options === null || options === void 0 ? void 0 : options.container) || currentContainer;
      return runWithContainer(cb, container);
    };

    const manager = {
      createPlugin,
      isPlugin,
      usePlugin,
      init,
      clear,
      run,
      registerHook,
      useRunner,
      clone
    };
    return manager;
  };

  return clone();
};
export const generateRunner = (hooksList, container, hooksMap) => {
  const runner = {};
  const cloneShape = closeHooksMap(hooksMap);

  if (hooksMap) {
    for (const key in cloneShape) {
      for (const hooks of hooksList) {
        if (!hooks) {
          continue;
        }

        if (hooks[key]) {
          cloneShape[key].use(hooks[key]);
        }
      } // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-expect-error


      runner[key] = (input, options) => cloneShape[key].run(input, _objectSpread({
        container
      }, options));
    }
  }

  container.write(RunnerContext, runner);
  return runner;
};
export const cloneHook = hook => {
  if (isWaterfall(hook)) {
    return createWaterfall();
  }

  if (isAsyncWaterfall(hook)) {
    return createAsyncWaterfall();
  }

  if (isWorkflow(hook)) {
    return createWorkflow();
  }

  if (isAsyncWorkflow(hook)) {
    return createAsyncWorkflow();
  }

  if (isParallelWorkflow(hook)) {
    return createParallelWorkflow();
  }

  if (isPipeline(hook)) {
    return createPipeline();
  }

  throw new Error(`Unknown hook: ${hook}`);
};
export const closeHooksMap = record => {
  if (!record) {
    return record;
  }

  const result = {};

  for (const key in record) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    result[key] = cloneHook(record[key]);
  }

  return result;
};

const includePlugin = (plugins, input) => {
  for (const plugin of plugins) {
    if (plugin.name === input.name) {
      return true;
    }
  }

  return false;
};

const sortPlugins = input => {
  let plugins = input.slice();

  for (let i = 0; i < plugins.length; i++) {
    const plugin = plugins[i];

    for (const pre of plugin.pre) {
      for (let j = i + 1; j < plugins.length; j++) {
        if (plugins[j].name === pre) {
          plugins = [...plugins.slice(0, i), plugins[j], ...plugins.slice(i, j), ...plugins.slice(j + 1, plugins.length)];
        }
      }
    }

    for (const post of plugin.post) {
      for (let j = 0; j < i; j++) {
        if (plugins[j].name === post) {
          plugins = [...plugins.slice(0, j), ...plugins.slice(j + 1, i + 1), plugins[j], ...plugins.slice(i + 1, plugins.length)];
        }
      }
    }
  }

  return plugins;
};

const checkPlugins = plugins => {
  for (const origin of plugins) {
    for (const rival of origin.rivals) {
      for (const plugin of plugins) {
        if (rival === plugin.name) {
          throw new Error(`${origin.name} has rival ${plugin.name}`);
        }
      }
    }

    for (const required of origin.required) {
      if (!plugins.some(plugin => plugin.name === required)) {
        throw new Error(`The plugin: ${required} is required when plugin: ${origin.name} is exist.`);
      }
    }
  }
};

export const isObject = obj => obj !== null && typeof obj === 'object';
export const hasOwnProperty = (obj, prop) => obj.hasOwnProperty(prop);